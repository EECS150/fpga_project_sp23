\section{Optimization}
\subsection{Overview}
Project requirements and grading will be different this semester than in recent semesters.
We would like to be as fair as possible and to give you an experience that closely matches what you will find in industry.
Therefore we will assign your project grade using a {\em figure of merit (FOM)} computed based on your design.
The FOM in this case will be a combination of your processor's maximum clock frequency ($F_{max}$), average cycles per instruction (CPI), and cost:

$$ FOM = \frac{F_{max}}{CPI \cdot cost}$$


$F_{max}$ is the maximum clock frequency at which your processor correctly passes our test benchmarks.
CPI is the average cycle per instruction for your processor running our benchmarks, as described below.
Cost will be based on which and how many FPGA elements your design includes, as detailed in the post place synthesis report.
It will be computed using a script that processes your report and forms a weighted sum of all the elements in your design.
The weights correspond to the relative chip area that each element occupies.  {\em We will not, however, include the cost of FPGA block RAM memory elements.}

We include {\em cost} in the FOM because we want to encourage simpler designs.
Experience shows that debugging times increases very quickly with design complexity, and in the past many students
have had trouble debugging complex designs by the end of the semester.
You will have a much better experience and learn more by keeping your design simple.
On the other hand, we would like you to explore options for improving performance.
But while doing so you should be mindful of whether or not extra complexity to improve performance is worth the extra cost.
Therefore if you are tempted to add complexity, make sure that it will actually improves the FOM.

The lab grading break down will be as follows:
\begin{description}
\item[50\%] Correctly functioning 3-stage (at least) processor, without regard for performance and cost.
\item[35\%] FOM optimizations.
\item[5\%] Checkpoints.
\item[10\%] Final report.
\end{description}

Once you have a functionally correct processor, the next steps will be to modify it to achieve a higher FOM and thus achieve a higher grade.
We will give you suggestions on how to maximize the FOM (and therefore your grade),
but it will be up to you to make good decisions as to how to optimize your design.

For purposes of computing the FOM, we will rely on two counters that you are required to implement as described in the project specification document.
One counts cycles and the other counts instructions.
%The RISC-V BIOS includes a command (``run'') for running a program.
Our benchmarks automatically clear the counters and reports the counts after the run.  In addition to using our benchmark programs you are welcome to write your own.
We will provide a script that takes as input the two counter values, your $F_{max}$, and a report (.rpt) file, and outputs the CPI and the FOM values.
For final checkoff we will use the $F_{max}$ value from running your processor on the FPGA board and will use the ``post\_place\_utilization.rpt'' file to determine the cost.
However, since place and route might take significant time as your design grows in complexity, to speed up your design space exploration, you might want
to use the ``post\_synth\_utilization.rpt'' file for costs, estimate $F_{max}$ based on your synthesis target and available slack from the timing report, and use simulation to get the cycle and instruction counts.  However, becasuse the simulator is significantly slower than running on the actual FPGA, this approach will only work for small benchmark programs.


It should go without saying that to improve the FOM, you will need to increase $F_{max}$, decrease $CPI$, decrease cost, or some combination of these.
You should be able to improve $F_{max}$ without substantially changing the microarchitecture of your design
by shortening the critical path.
Of course, after you improve one path, you might then want to optimize the next longest.
Improving a path could come down to how you write the Verilog, or you might need to rearrange the logic.
Also, obviously, increasing the number of pipeline stages might also shorten the critical path, but such a change could have an adverse effect on CPI and cost; so proceed with caution.
In this design, a small Dcache and/or Icache might also help improve $F_{max}$, if you can find a way to build a cache that is substantially faster than block RAM.
To improve CPI, you might consider using branch prediction.
Also, you might even want to consider mechanisms that would bring CPI below 1 --- however, these mechanisms can get tricky to design.
If you have other ideas and are unsure if it will help, feel free to talk with us and get our feedback before investing time in an idea that may or may not work out.

For a 3-stage unoptimized design, we expect typical values around: $F_{max}$ = 60~MHz, CPI = 1.5, and cost = 1.5~M, and therefore a FOM of around 25.

At a later date we will post approximate FOM grade targets (what FOM values correspond to project point assignments).
Also, we will try to find a way to occasionally anonymously post updates on FOM values that other groups have achieved.


\subsection{Scripts}
Several scripts are provided to calculate the FOM of your design.
After compiling the programs (\verb|make| in the \verb|software| directory),
you can simply run
\begin{minted}{bash}
  ./script/fom.py
\end{minted}
in the \verb|hardware| directory.
It returns the estimated FOM based on CPIs for small benchmarks.
Since we have multiple benchmark programs (we will add more later),
the CPI is calculated as a geometric mean of all benchmarks.

To get the actual FOM using the real CPI, use \verb|-r| option.
It calls \verb|run_fpga.py| for all benchmarks to obtain the real CPI.
Make sure you program the FPGA and close your screen before running the script.

The cost is calculated based on one of the following:
\begin{itemize}
\item \verb|./build/synth/post_synth_utilization.rpt|
\item \verb|./build/impl/post_place_utilization.rpt|
\end{itemize}
By default, the \verb|fom.py| script compares the last modification time and uses the newer one.
You can force it to use \verb|./build/synth/post_synth_utilization.rpt| with \verb|-s| option,
or the other one with \verb|-i| option.
Use \verb|-u| option to specify the report in other location.
Note that for the final grade, we will use \verb|./build/impl/post_place_utilization.rpt|.

The maximum frequency is automatically read from timing summary reports:
\begin{itemize}
\item \verb|./build/synth/post_synth_timing_summary.rpt|
\item \verb|./build/impl/post_rote_timing_summary.rpt|
\end{itemize}
\verb|clk_out1_design_1_clk_wiz_0_1| in the report is the clock signal driving your CPU.
By default, it uses the one in the same directory as the selected resorce utilization report.
You can manually specify it with \verb|-t| option.
Again, we will use \verb|./build/impl/post_rote_timing_summary.rpt| for the final grade.
Do not forget to adjust \verb|CPU_CLOCK_PERIOD| in \verb|z1top.v| after you modified your datapath.
The detailed instructions are in Sec. \ref{sec:target_clock_frequency}.

You can manually override each of cost, $F_{max}$, and CPI with \verb|-c|, \verb|-f|, and \verb|-p| option, respectively.

The following boxes show the log of \verb|fom.py| on unoptimized 2-stage pipeline for your reference.
After some exploration, the maximum frequency for this design turned out to be 62.5~MHz (\verb|CPU_CLOCK_PERIOD=15|).
The estimated FOM was 30.54 as shown below.
\usemintedstyle{bw}
\begin{minted}[breaklines, frame=single]{bash}
$ ./scripts/fom.py
Using build/impl/post_place_utilization.rpt (last modified: Wed Apr  5 03:06:32 2023)
Using build/impl/post_route_timing_summary.rpt (last modified: Wed Apr  5 03:08:05 2023)
Running simulation...
Result: 000000e0
Cycle Count: 00005483
Instruction Count: 00004476
[     27974 sim. cycles] mmult PASSED!
Result: 0000004f
Cycle Count: 00007d03
Instruction Count: 00005bf3
[     37929 sim. cycles] bdd PASSED!
...simulation complete
Cycle Counts: [21635, 32003]
Instruction Counts: [17526, 23539]
CPIs: [1.23, 1.36]
CPI (geomean): 1.30

Fmax: 62.5
CPI: 1.30
Cost: 1579727

FOM (estimate): 30.54
\end{minted}

For the actual FOM, we have to run the benchmarks on the FPGA with \verb|-r| option.
Here, as an example, we manually gave cost and $F_{max}$.
\usemintedstyle{bw}
\begin{minted}[breaklines, frame=single]{bash}
$ ./scripts/fom.py -r -f 62.5 -c 1579727
Running on FPGA...
Sending command: file 30000000 6100
Sent 6100/6100 bytes
Done
Sending command: run
Result: 000017a4
Cycle Count: 0057e4d8
Instruction Count: 003d2ef4
Done
Sending command: file 30000000 2368
Sent 2368/2368 bytes
Done
Sending command: run
Result: 0001f800
Cycle Count: 00f50332
Instruction Count: 00c4c2ed
Done
...FPGA run complete
Cycle Counts: [5760216, 16057138]
Instruction Counts: [4009716, 12894957]
CPIs: [1.44, 1.25]
CPI (geomean): 1.34

Fmax: 62.5
CPI: 1.34
Cost: 1579727

FOM: 29.58
\end{minted}

As you can see, the real CPIs are different from what we got in simulation,
since benchmark sizes are different.
That is, you should compare an estimated FOM with another estimated FOM,
and an actual FOM with another actual FOM, not in a mixed manner.


\newpage
